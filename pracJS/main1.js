// 1. 변수: 이름저장
// 문자는 따옴표로 감싸기

// 변수타입: 
// 문자, 숫자, $, _만 사용할 수 있음
// 예약어, 첫글자숫자 사용할 수 없음

// var: 중복선언 가능. 함수레벨 스코프.
// let: 중복선언 불가. 재할당 가능. 자바의 변수랑 비슷. 블록레벨 스코프.
// const: 중복선언 불가, 재할당 불가. 자바의 상수랑 비슷. 대문자로 선언하여 상수라는 것을 알리자


// 전역변수와 지역변수
// 지역변수는 전역변수와 동일한 이름으로 선언할 수 있으며 서로 간섭하지 않는다.
// (그러나 헷갈린다 일케 쓰면. ... )


// 2. 기본 출력:
// console.log();  // 콘솔

// 3. 자료형
// 문자열: String; "", '', `` 사이에 씀. (``는 문자 내부에 변수 사용할 때 쓰면 좋음.);
let num3 = 3;
const message3 = `testNum: ${num3}`;
const message3_1 = `testNum+2: ${num3+2}`;

console.log(message3);
console.log(message3_1);

//result(console)
// testNum: 3
// testNum+2: 5

// 숫자형: number // int, double, long 등의 구분이 없음. 소수도 가능
// 1을 0으로 나누면 infinity;
// 문자열을 숫자로 나누면 NaN(not a number이라는 뜻)

// 논리형: boolean // true, false;

// null: 존재하지 않음
// undefined: 존재하나 값이 할당되지 않음
// 객체형: object

///////////////////////////////////////
// 4. typeof
// typeof 연산자는 자료형을 알 수 있음. 
// 자바스크립트는 자료형이 유연한 언어이기때문에 이걸 통해 조건을 주어서 자료형에 따라 데이터를 따로 처리하거나 할 수 있음.
//ex)
console.log(typeof 'a');


////////////////////////////////////
// 5. 사용자와 알림창으로 상호작용하기
// alert(); 알림의 용도. 확인버튼만 존재
// prompt(); 값을 입력받을 때 사용. 값을 넣을 수 있음. 
// 입력받은 값을 문자열 자료형으로 반환함.
// 값을 넣지 않고 닫으면 null 입력됨
// 파라미터를 둘 받을 수도 있는데, 두번째 메시지는 미리 들어갈 수 있는 디폴트값임.

// ex
const name5 = prompt("이름을 입력하세요");
alert(`환영합니다, ${name5}님.`);

// confirm(); 확인과 취소버튼이 나옴. 확인받는 용도. 
// 확인: true // 취소: false 반환

// 알림창을 사용하는 동작은 알림창 동작을 중지할 때 까지 스크립트가 일시중지됨에 유의.
// 또한 위치와 모양을 정할 수 없다.

// 6. 형변환
// String(); 문자형으로 변환하여 반환
// Number(); 숫자형으로 변환하여 반환
// Boolean(); 논리형으로 변환하여 반환

// 자바스크립트는 자동형변환이 이루어지는데, 
//이런 과정이 의도않은 동작을 야기할 수 있으므로 명시적 형변환을 해주자.

// Number(); 의 경우 문자 혹은 undefined를 파라미터로 넣으면 NaN반환, true와 flase를 넣으면 각각 1과 0으로 반환, null은 0으로 반환
// Boolean() 의 경우 넣는 파라미터에 따라 반환하는게 조금 다름
// false 반환: 숫자 0, 빈 문자열, null, undefined, NaN
// 이 외에는 모두 true 반환. 값이나 숫자가 있는 경우, infinity의 경우 등등


// 7. 기본연산자 (중 자바와 다른 것)
// 거듭제곱: ** 
// console.log(2**3); ->  2^3 -> 8
// 복합대입연산자, 증감연산자 사용가능

// 8. 비교연산자
// 자바와 유사, 다만 일치연산자라는게 있음.
// ==  : 값만 같으면 true반환 (자동으로 형변환 해줌)
// === : 값과 타입 모두 같아야 true 반환함.

// 9. 논리연산자
// 자바와 동일
// 논리연산자를 사용해 변수를 초기화할 수 있음. 이 부분 나중에 알아보기

// 10. 조건문 문법
// 자바와 동일


////////////////////////////////////////////////////////////////////
// 11. 반복문

// for문: 자바와 동일하나 초기식 / 조건식 / 증감식에서 초기식의 타입지정이 let(주로)으로 들어감에 유의
// for (let i=0; i<5; i++) {
//      console.log(i);   
// }
// while문: 동일
// do while문: 동일
// switch문: 동일

///////////////////////////////////////////////////
//////////////////////////////////////////////////


// 스코프: 대상에 접근할 수 있는 범위.
// 전역스코프: 어디에서나 접근가능
// 지역스코프: 특정한 범위에서만 접근할 수 있음.
// 지역스코프의 대표적인 예: 함수스코프. 함수 안에서 선언된 지역변수는 그 함수 안에서만 쓸 수 있음.
// 함수 밖에서는 호출 불가.


///////////////////////////////////////////////////
///////////////////////////////////////////////////

// 12. 함수
// 기본적인 문법은 자바와 유사하다. 
// 문법:
// 함수 함수명(파라미터)  {
//      코드;
//      return 반환할 값;
// }

// 매개변수의 디폴트값을 설정할 수 있음. 

// function sayHello(name = "friend") {
//    console.log(`hello, ${name}`);
// }
// 이렇게 하면 sayHello(), sayHello(name) 둘 다 쓸 수 있음

// 13. 함수선언문과 함수표현식, 호이스팅
// 바로 위에서 했던 것이 함수 선언문.
// 함수선언문과 함수표현식의 차이: 함수생성시점.

// 자바스크립트는 프로그램을 실행하기 전에 코드 내부의 함수선언문들을 전부 미리 호출하여 함수모음을 만든다.
// 그때 함수선언문이 미리 읽혀, 함수선언이 함수사용시점보다 아랫줄에 위치하고 있어도 그 함수를 사용가능하다.
// 이를 호이스팅이라고 함. 스코프 내부 어디서든 변수 선언은 최상위에 선언된 것처럼 행동하는 것.
// var 변수, 그리고 함수선언문이 이 호이스팅 영향을 받음.
// 그러면 함수표현식, let, const는? TDZ에 위치하고 있음. Temporal Dead Zone. 코드를 예측가능하게 하고 불필요한 에러를 줄임.

// 반면 함수표현식은 해당코드에 도달해서야 함수가 생성되며 생성 이후에만 사용할 수 있음.

// 함수표현식 문법:
// 타입지정 함수명혹은변수명 = function(파라미터) {
//      코드나 반환값
// }
// 사용할 땐 일반 함수와 똑같음. 

// 14. 화살표함수
// 함수선언문을 간단하게 쓰는 방법. 
// function을 지우고 화살표를 쓴당.

// 타입지정 함수명 = (파라미터) => {
//      코드;   
// }

// 한줄 분량의 연산을 수행하는 짧은 함수의 경우 리턴값만 적을 수도 있다.
// 타입지정 함수명 = (파라미터) => 리턴값;

/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////

// 15. 객체
// Object 타입. 컬럼명-값으로 이루어진 데이터집합? map이랑 비슷해보임. 
// 문법:
// 변수타입 변수명 = {
//   컬럼 : 프로퍼티,
//   컬럼 : 프로퍼티,
//   컬럼;    
// }
// 컬럼과 프로퍼티가 동일하면 축약형으로 쓸 수 있음 (168줄)

// 접근할 때는 변수명.컬럼 으로 접근. 변수명[컬럼] 으로도 가능함.
// 추가할 때도 접근방법과 동일.
// 삭제는 delete 키워드를 사용. delete 변수명.컬럼;
// 단축 프로퍼티

// 존재하지 않는 프로퍼티에 접근하면 undefined 출력.
// 프로퍼티 존재 여부를 확인하려면 in 키워드 사용 .
 // let check = '컬럼명' in 변수명; 
 // console.log(check); 

 // for in 반복문
 // 객체를 순회하면서 값을 얻음. foreach와 유사.
 // for (let key in 객체명) {
 //     console.log(key);  키값 가져오기, 여기서 key가 순회하는 건 컬럼명
 //     console.log(superman[key]);  가져온 키로 프로퍼티까지 가져올 수 있음.
 // }

 // 16. 객체 메소드
 // 객체 프로퍼티로 할당된 함수를 메소드라 부름.
 // 변수타입 변수명 = {
 //   컬럼 : 프로퍼티,  
 //   컬럼명 : function() {
 //      메소드내부코드;
 //   } 
 // }
 // 이때, 메소드에서 객체 내부 프로퍼티를 사용하고 싶을 때 this 키워드를 사용함.

 // ex)
    const boy = {
        name: 'Mike',
        sayHello: function() {
            console.log(`Hello, ${this.name}`);
        },
        sayBye() {    //축약형. function 생략.
            console.log(`Bye, ${this.name}`);
        }
    }
    
// 여기서, 메소드는 화살표함수로 선언할 수 없음. 화살표함수는 일반 함수와는 달리 자신의 this를 
// 가지지 않고, 외부에서 값을 찾음.
// 자바스크립트에서 this가 엄청 복잡한 설명이니 ..... 힘내장!

// 16.5 생성자함수
// 객체를 생성하는 역할을 하는 함수. 첫글자를 대문자로 쓰는 것이 관례. 

function User(id, pw) {
    this.id = id;
    this.pw = pw;
}

let user1 = new User('qwerty', 'qwerty');

 //////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////

 // 17. 배열
 // 쉽게, 인덱스가 존재하는 리스트. 인덱스는 0부터 시작
 let students = ['amy', 'betty', 'charlie', 'david'];
 // 배열은 문자, 숫자, 객체, 함수 등 모든 타입의 자료를 포함할 수 있음.
 // length는 배열의 길이를 나타냄. 
 // push(param); 배열 제일 끝에 파라미터를 추가하는 메소드
 // pop(); 배열 제일 끝의 값을 삭제함.
 // shift(param1, param2 ...); 배열 제일 앞에 값을 넣는데, 여러개를 넣을수도 있음.
 // unshift(); 배열 앞에 넣은 값을 삭제

 // forOf문: for in과 유사하나 forIn은 객체, forOf는 배열을 순환한다는 차이가 있음. 단 forOf문은 인덱스를 알 수 없음에 주의

 for (let student of students) {
    console.log(student);
 }